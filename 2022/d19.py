import pprint as pp
import re
from collections import deque


def parse(text):
    # Blueprint 1:
    #   Each ore robot costs 4 ore.
    #   Each clay robot costs 4 ore.
    #   Each obsidian robot costs 4 ore and 14 clay.
    #   Each geode robot costs 2 ore and 16 obsidian.
    #
    # idx, ore_cost, clay_cost, obsidian_cost_in_ore, obsidian_cost_in_clay, geode_cost_in_ore, geode_cost_in_obsidian
    # idx, o, c, ob_ore, ob_clay, g_ore, g_obsidian
    return [list(map(int, re.findall("(\d+)", line))) for line in text.split("\n")]


def best_possible_geode_count(ng, rg, t):
    # Heuristic taken from
    # https://github.com/agubelu/Advent-of-Code-2022/blob/master/src/days/day19.rs
    #
    # The material that we already have...
    # plus the material that will be generated by the existing robots...
    # plus the optimistic assumption that one new robot will be added every turn (1 + 2 + ... + i)
    return ng + rg * t + t * (t - 1) // 2

def best_possible_obsidian_count(nob, rob, t):
    """same as before"""
    return nob + rob * t + t * (t - 1) // 2


def solve(o: int, c: int, ob_ore: int, ob_clay: int, g_ore: int, g_obsidian: int, T: int) -> int:
    """
    BFS with memoization. Need to explore the entire search space so pretty slow
    """
    # How many resources we have, and how many of each resources we have
    # at first: 0 resources, and 1 robot for ore
    Q = deque([(0, 0, 0, 0, 1, 0, 0, 0, T)])
    max_nb_geodes = 0
    SEEN = set()
    max_ore_required = max([o, c, ob_ore, g_ore])
    while len(Q) > 0:
        no, nc, nob, ng, ro, rc, rob, rg, t = Q.popleft()

        if t == 1:
            # Normally, we should stop at 0, but we can skip a search step
            # Even if we built a robot now there's not enough time for it to produce anything,
            # we can stop searching here and add whatever the geode robots would have produced next
            max_nb_geodes = max(max_nb_geodes, ng+rg)
            continue

        if best_possible_geode_count(ng, rg, t) < max_nb_geodes:
            continue
        # If there is no way to have enough obsidian to build a new geode,
        # we know the best possible count of geodes weâ€™ll be able to build
        if best_possible_obsidian_count(nob,rob, t) < g_obsidian:
            max_nb_geodes = max(max_nb_geodes, ng + rg*t)
            continue

        # Do not produce more resources or robots than necessary
        ro = min(ro, max_ore_required)
        rc = min(rc, ob_clay)
        rob = min(rob, g_obsidian)
        no = min(no, t * max_ore_required - ro * (t - 1))
        nc = min(nc, t * ob_clay - rc * (t - 1))
        nob = min(nob, t * g_obsidian - rob * (t - 1))
        # thus, we can feed the memoization with already seen states
        S = (no, nc, nob, ng, ro, rc, rob, rg, t)
        if S in SEEN:
            continue
        SEEN.add(S)

        # If we have the resources, we build a new robot
        # Start with geodes since they are the most important
        if no >= g_ore and nob >= g_obsidian:  # geode robots
            Q.append((no - g_ore + ro, nc + rc, nob - g_obsidian + rob, ng + rg, ro, rc, rob, rg + 1, t - 1))
        if no >= o:  # ore robot
            Q.append((no - o + ro, nc + rc, nob + rob, ng + rg, ro + 1, rc, rob, rg, t - 1))
        if no >= c:  # clay robot
            Q.append((no - c + ro, nc + rc, nob + rob, ng + rg, ro, rc + 1, rob, rg, t - 1))
        if no >= ob_ore and nc >= ob_clay:  # obsidian robot
            Q.append((no - ob_ore + ro, nc - ob_clay + rc, nob + rob, ng + rg, ro, rc, rob + 1, rg, t - 1))

        # Extract resources with the existing robots, but do not build a new robot
        Q.append((no + ro, nc + rc, nob + rob, ng + rg, ro, rc, rob, rg, t - 1))
    return max_nb_geodes


text = open(f"d19.txt").read().strip()

blueprints = parse(text)
part1 = 0
part2 = 1
for idx, o, c, ob_ore, ob_clay, g_ore, g_obsidian in blueprints:
    nb_geodes = solve(o, c, ob_ore, ob_clay, g_ore, g_obsidian, 24)
    part1 += idx * nb_geodes
    # if idx <= 3:
    #     part2 *= solve(o, c, ob_ore, ob_clay, g_ore, g_obsidian, 32)
print(part1)
print(part2)
